<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2048</title>

    <style>
        html, body {
            box-sizing: border-box;
            font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
            height: 100%;
            margin: 0;
            padding: 0;
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2em;
            height: 100vh;   /* Ensures full viewport height */
            margin: 0;
            padding: 2rem;
            box-sizing: border-box;
        }
        #gameOver {
            color: #756452;
            text-align: center;
            margin: 0;
            padding: 0;
        }
        .hide {
            display: none;
        }
        #header {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 1em;
        }
        #header > h1 {
            grid-row: 1 / span 2;
            margin: 0;
            padding: 0;
            aspect-ratio: 1 / 1;
            /*Styling text */
            color: white;
            font-size: 3em;
            /*To center text*/
            display: flex;
            align-items: center;
            justify-content: center;
            /*Rounded border*/
            background-color: #f2cf54;
            border-width: 0;
            border-radius: 0.25em;

        }
        #header .score {
            margin: 0;
            padding: 0.5em;
            /*Styling text*/
            font-size: 1.25rem;
            font-weight: bold;
            color: white;
            /*To center text*/
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            /*Rounded border*/
            background-color: #897864;
            border-width: 0;
            border-radius: 0.5rem;
        }
        #header .score > :first-child {
            color: #e7d6c2;
        }
        #header .score p {
            margin: 0;
            padding: 0;
        }
        #header > #restart {
            margin: 0;
            padding: 0.5em;
            grid-column: 2 / span 2;
            /*Styling text*/
            font-size: 1.25rem;
            font-weight: bold;
            color: white;
            /*Rounded border*/
            background-color: #f58f5d;
            border-width: 0;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: 0.2s linear;
        }
        #header > #restart:hover {
            background-color: #f55a36;
        }
        [id="2048"] {
            display: grid;
            height: 100%;
            aspect-ratio: 1 / 1;
            gap: 0.75em;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr 1fr;
            place-content: center;
            background-color: #897864;
            /*Rounded border*/
            border: 0.75em solid #897864;
            border-radius: 0.75em;
        }
        [id="2048"] > div {
            /*Font*/
            font-weight: bold;
            font-size: 2.5em;
            color: white;
            /*To make boxes fill*/
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            /*To center text*/
            display: flex;
            align-items: center;
            justify-content: center;
            /*Rounded border*/
            background-color: #bdac97;
            border-width: 0;
            border-radius: 0.25em;
        }
        /*Darker fonts for #2 and #4*/
        [id="2048"] > :is(.\32, .\34) {
            color: #756452;
        }
        /*Colors for each number*/
        [id="2048"] > :is(.\32) {
            background-color: #eee4da;
        }
        [id="2048"] > :is(.\34) {
            background-color: #ebd8b6;
        }
        [id="2048"] > :is(.\38) {
            background-color: #f2b075;
        }
        [id="2048"] > :is(.\31\36) {
            background-color: #f58f5d;
        }
        [id="2048"] > :is(.\33\32) {
            background-color: #f47658;
        }
        [id="2048"] > :is(.\36\34) {
            background-color: #f55a36;
        }
        [id="2048"] > :is(.\31\32\38, .\32\35\36, .\35\31\32, .\31\30\32\34, .\32\30\34\38) {
            background-color: #f2cf54;
        }
        .new {
            animation: pop-in 0.3s;
            animation-iteration-count: 1;
            animation-timing-function: ease;
        }
        @keyframes pop-in {
            0% {
                transform: scale(0.75);
                opacity: 0.8;
            }
            75% {
                transform: scale(1.005);
                opacity: 1;
            }
            100% {
                transform: scale(1);
                opacity: 1;
        }
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="header">
            <h1>2048</h1>
            <div class="score">
                <p>SCORE</p>
                <p id="score"></p>
            </div>
            <div class="score">
                <p>BEST</p>
                <p id="best"></p>
            </div>
            <button id="restart">RESTART</button>
        </div>
        <h1 id="gameOver" class="hide">Game Over</h2>
        <div id="2048">
        </div>
    </div>
</body>
<script>
    const GAME_OVER = document.getElementById("gameOver");
    const HEADER = document.getElementById("header");
    const GAME = document.getElementById("2048");
    const RESTART = document.getElementById("restart");
    const SCORE = document.getElementById("score");
    const BEST = document.getElementById("best");

    let score = 0;
    let best = Number(localStorage.getItem("bestScore")) || 0;

    const GRID = new Array(4); // Create 4x4 array

    function syncHeaderWidth() {
        HEADER.style.width = `${GAME.getBoundingClientRect().width}px`;
    }

    function updateScore(num) {
        score += num; // Add to score
        SCORE.innerText = score; // Update score display

        if (score > best) { // If new best score, update best score
            best = score;
            BEST.innerText = best;
            localStorage.setItem("bestScore", best);
        }
    }

    function resetScore() {
        score = 0; // Reset score
        SCORE.innerText = score;
        BEST.innerText = best;
    }

    function init(restart = false) {
        resetScore(); // Reset score
        if (!restart) {
            // Adding divs to container and GRID
            for (let row = 0; row < GRID.length; row++) {
                GRID[row] = [];
                for (col = 0 ; col < 4; col++) {
                    const div = document.createElement("div"); // Create div
                    GRID[row][col] = div; // Add div to GRID
                    GAME.appendChild(div); // Add div to container
                }
            }

            // Add event listeners
            window.addEventListener("keydown", play);
            RESTART.addEventListener("click", () => init(true));

            // Sync after window load
            window.addEventListener("load", () => {
                syncHeaderWidth();
                setTimeout(syncHeaderWidth, 100);
            });

            // Sync on resize
            window.addEventListener("resize", syncHeaderWidth);

        } else {
            // Clear tiles
            const tiles = getTiles();
            tiles.forEach(tile => { changeTile(tile, ""); });
        }

        // Start with 2 random tiles)
        randomTile();
        randomTile();

    }

    function play(e) {
        if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) {
            e.preventDefault(); // Prevent default scrolling behavior
            move(e.key); // Call move function with appropriate direction
        }
    }

    function getTiles() {
        const children = GAME.children // Select all children of 2048
        const tiles = Array.from(children); // Convert HTML collection to array
        return tiles;
    }

    function isGridFull() {
        return ( getTiles().filter(val => val.innerText).length === 16 );
    }

    function randomTile() {
        const empty = getTiles().filter(div => div.innerText === ""); // Filter for empty divs
        if (empty.length === 0) return; // If no empty divs, return

        const randomDiv = empty[Math.floor(Math.random() * empty.length)]; // Select a random empty div
        const number = Math.random() < 0.9 ? 2 : 4; // If random number is less than 0.9, set number 2, else set to 4

        changeTile(randomDiv, number, true); // Change tile to random number

        // If grid full, check for game over
        if (isGridFull()) { checkGame() };
    }

    function changeTile(div, num, isNew = false) {
        div.innerText = num; // Set innerText
        div.className = num; // Set class name

        if (isNew) {
            div.classList.add("new"); // Add new class to animate
        }

    }

    function move(direction) {
        const row = direction === "ArrowLeft" || direction === "ArrowRight";
        const reverse = direction === "ArrowRight" || direction === "ArrowDown";
        let noMoves = true;

        for (let i = 0; i < 4 ; i++) {
            let line = [];

            for (let j = 0; j < 4 ; j++) {
                // Get tile
                // if LR = GRID[ROW][COL]
                // else if UD = GRID[COL][ROW]
                let tile = row ? GRID[i][j] : GRID[j][i];
                line.push(parseInt(tile.innerText)); // Add tile values to line
            }

            if (reverse) line.reverse(); // If moving right or down, reverse elements to iterate in correct direction
            let newLine = slideAndMerge(line); // Slide and merge values in line
            if (reverse) newLine.reverse(); // Reverse again to return to original order

            for (let j = 0; j < 4 ; j++) {
                // Get tile
                // if LR = GRID[ROW][COL]
                // else if UD = GRID[COL][ROW]
                let tile = row ? GRID[i][j] : GRID[j][i];
                 // Update tile values if they are different
                if (tile.innerText != newLine[j]) {
                    changeTile(tile, newLine[j]);
                    noMoves = false; // Set noMoves to false
                };
            }

        }

        // If no moves can be made
        if (noMoves) {
            // If grid is full, check for game over
            if (isGridFull()) {
                checkGame();
            }
            return;
        }

        randomTile(); // Add new tile if game hasn't ended and moves are available
    }

    function slideAndMerge(line) {
        let newLine = line.filter(val => val); // Remove blanks

        for (let i = 0 ; i < newLine.length - 1; i++) { // Iterate through array
            if (newLine[i] === newLine[i + 1]) { // If values are the same, merge
                newLine[i]*=2; // Double first value
                newLine[i + 1] = ""; // Empty second value
                updateScore(newLine[i]); // Update score
            }
        }

        newLine = newLine.filter(val => val); // Filter again to get rid of spaces inbetween
        while (newLine.length < 4) newLine.push(""); // Add empty tiles to make array length 4

        return newLine;
    }

    function checkGame() {
        let gameOver = true;

        for (let row = 0; row <= 3; row++) {
            for (let col = 0; col <= 3; col++) {
                let current = GRID[row][col].innerText;
                // Check right neighbor
                if (col <= 2 && current === GRID[row][col + 1].innerText) {
                    gameOver = false;
                }
                // Check bottom neighbor
                if (row <= 2 && current === GRID[row + 1][col].innerText) {
                    gameOver = false;
                }
            }
        }

        if (gameOver) { endGame() };
    }

    function endGame() {
        GAME_OVER.classList.remove("hide"); // Show game over message
        window.removeEventListener("keydown", play); // Remove event listener for keydown
    }

    // Start game
    init();

</script>
</html>